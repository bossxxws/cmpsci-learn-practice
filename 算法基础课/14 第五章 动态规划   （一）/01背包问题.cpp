//常用模型 背包模型
//线性dp      区间dp
//计数类dp    数位统计dp 
//状态压缩dp  树形dp
//记忆化搜索

//01背包问题
//N个物品 和一个 容量是V的背包
//每个物品有两个属性：
//体积：Vi Wi       每件物品仅用一次

//完全背包
//每件物品有无限个

//多重背包
//每个物品最多有Si个（S不一样）

//分组背包问题
//分组：每一组里的物品有若干种（一组里面最多选一个物品）


//01背包问题：
//用动态规划解决

//1、状态表示f（i，j） 一般是有两维 用f（i，j）表示
//f（i，j）表示的是一个集合，集合表示所有选法，条件：
//1、只从前i个物品中选 2、选出来的物品的总体积<=j
//属性（max，min，数量）这里选最大值属性

//2、状态计算 --- 集合划分 考虑清楚如何一步一步把每个状态计算出来
//f（i，j）这个集合划分成两大类：
//不含i（不包含第i个物品）（所有只从1~i-1中选，且总体积不超过j）---f（i-1，j）；
//含i（包含第i个物品）f（i-1，j-vi）+wi
//子集的划分，一般来说要做到两个原则：不重，不漏  （不一定所有时候都要满足不重）
//dp的优化一般来说是对dp的代码或（方程）者计算问题进行一个等价变形

//考虑的时候从最朴素的方式出发

//所有的动态规划问题都可以用这样的思考方式

#include<bits/stdc++.h>

using namespace std;

const int N=1010;

int n,m;

int v[N],w[N];

int f[N][N];

int main()
{
    cin>>n>>m;
    
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
    
    for(int i=1;i<=n;i++)
        for(int j=0;j<=m;j++)//j最大是m，背包大小
        {
            f[i][j]=f[i-1][j];//从前i个物品选，体积不超过j
            if(j>=v[i])f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);
            //只有当j>=v[i]的时候才存在包含第i个物品的情况
        }
    cout<<f[n][m]<<endl;
    return 0;
}
