/*

状态表示：f[i][j]：

	集合：表示所有从0走到j，走过的所有点是i的所有路径（走过的所有点存在i中）
    i是一个二进制数字，其中的01表示哪个点走过没有
    
    属性：Min 

状态计算： f[i][j]=min(f[i][j],f)
	
*/
#include<bits/stdc++.h>

using namespace std;

int n;

const int N=21,M=1<<N;

int w[N][N]; 

int f[M][N];

int main()
{
	cin>>n;
	
	//注意点的编号是0~n-1而不是1~n
	
	//所以在最后阶段枚举的时候我们枚举到n-1即可
	
	//最后输出f[1 << n -1 ][n-1]
	
	//(第一个n-1表示11......1111110,表示所有点都走了一遍) 
	
	//(第二个维度的n表示走到n-1(终点是n-1)) 
	
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		{
			scanf("%d",&w[i][j]);
		} 
		
	memset(f,0x3f,sizeof f);
		
	//cout<<111;
	
	f[1][0]=0;
		//for(int i=0;i<n;i++)
		//for(int j=0;j<n;j++)
		//{
			//cout<<w[i][j]; 
		//} 
	for(int i=0;i< 1 << n;i++)//枚举每个状态
	//(枚举到11........1111110，1111....11不枚举因为最终状态到不了这里（n）)
	{
		for(int j=0;j<n;j++)//在某个状态时，枚举走到每个点的时候的转移状态
		{
			//终点为j 
			if(i>>j & 1)//如果这条路能走到j点 
			{
				for(int k=0;k < n;k++)//想从k点转移过去 
				{
					if( ( i - ( 1 << j ) ) >> k & 1 )
					//除去j这个点，如果包含k就可以加上k的权重 
					{
						f[i][j]=min(f[i][j],f[i - (1 << j)][k]+w[k][j]);//包含k这个点
						//（k连接j的前一个点（k）和j点） 
					}
				} 
			}
		} 
	}
	
	cout<<f[(1<<n)-1][n-1];//(1<<n)-1表示所有的点都走过了 
	
	return 0;
}

/*
5
0 2 4 5 1
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0

18

*/
