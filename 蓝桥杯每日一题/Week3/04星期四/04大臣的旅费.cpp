//----------------------------------------------------------------------------------------

//从首都到达每个大城市的方案都是唯一的,所以这是一颗树
//求这棵树的直径（）
 
/*----------------------------------------------------------------------------------------

树的直径的定义

在一棵树中，每一条边都有权值，树中的两个点之间的距离，定义为连接两点的路径上边权之和，
那么树上最远的两个点，他们之间的距离，就被称之为，树的直径。
树的直径的别称，树的最长链。
请注意：树的直径，还可以认为是一条路径，不一定是只是一个数值。

*///--------------------------------------------------------------------------------------

//二次dfs求数的直径

//1、随意选一个点x，开始搜索，找到离着当前节点最远的节点y
//2、从上一轮搜索到的最远节点y，再次搜索一遍，找到离这个节点最远的节点z 
//3、y到z的路径就是树的直径 

//----------------------------------------------------------------------------------------
/*
5
1 2 2
1 3 1
2 4 5
2 5 4
*/
#include<bits/stdc++.h>

using namespace std;

const int N=1e5+3;

int h[2*N],e[2*N],w[2*N],ne[2*N],idx=0;

int n;

int maxd=-1,maxu;
 
void add(int a,int b,int c)
{
	e[idx]=b;
	w[idx]=c;
	ne[idx]=h[a];
	h[a]=idx++;
}

void dfs(int son,int father,int d)
{
	//cout<<"yes";
	//cout<<a<<" "<<h[a]<<endl;
	for(int i=h[son];i!=-1;i=ne[i])
	{
		//cout<<"yes";
		int j=e[i];//j是son的子节点 
		int k=w[i];
		if(j==father)continue;//避免回头访问，确保每个节点只被访问一次 
		if(maxd<k+d)
		{
			//cout<<"yes";
			maxd=k+d;
			maxu=j;
		}
		dfs(j,son,d+k);
	}
}

int main()
{
	memset(h,-1,sizeof h);
	cin>>n;
	
	for(int i=1;i<=n-1;i++)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		//边权为c，由于是无向图，加两次 
		add(a,b,c);
		add(b,a,c);
	}
	
	dfs(1,-1,0);//到-1就是遍历所有，得出距离最远的的点和最大的距离 
	
	dfs(maxu,-1,0);//寻找maxu的最远的点和最大的距离
	
	long long sum=(long long)(11+maxd+10)*(maxd)/2;
	
	cout<<sum;
	
	return 0;
}
